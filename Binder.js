'use strict';

var _ = require('underscore'),
  Backbone = require('backbone'),
  WidgetModel = require('./Models/WidgetModel');

/**
 * Represents a binder instance.
 *
 * Each binder instance should be associated with exactly one editor instance.
 *
 * This object should not be created directly. To create binders:
 *
 * @code
 * require('widget-binder').open($editorElement);
 * @endcode
 *
 * The binder couples all the objects needed to track widget data and perform
 * downstream synchronization from the server.
 *
 * Widget Lifecycle:
 *
 *   Create:
 *     When a widget is created it should call the 'bind' method on the binder
 *     to instruct the binder to start tracking the widget. This binds the
 *     editor widget to a server side data model and renders the widget using
 *     that model. It also attaches actions to the widget that users may
 *     perform, and sets up inline editing.
 *
 *   Edit:
 *     When an edit action is requested, the sync protocol requests that the
 *     server allow the user to edit widget's associated data entity model. If
 *     the markup changes, the widget is re-rendered and existing inline edits
 *     are preserved.
 *
 *   Duplicate:
 *     Since each widget is bound to a unique data entity on the server,
 *     operations like copy and paste, or moving a widget to a different part
 *     of the document may result in the widget's associated data entity being
 *     duplicated on the server. If this occurs, the widget will be re-rendered
 *     with its new references, again preserving inline edits.
 *
 *   Export:
 *     When the content author is finished editing, the editor perform cleanup
 *     on the markup. As a part of this "cleanup", the client calls the 'save'
 *     method to generate the "export markup", which is what will get sent to
 *     the server.
 *
 *   Destroy:
 *     When a widget is destroyed in the editor, the client calls the 'destroy'
 *     method to unbind and free all references to the widget.
 *
 * @param {Backbone.View} editorView
 *   The view that will be used to keep the editor root element in sync.
 *
 * @constructor
 */
module.exports = function(editorView) {
  this._editorView = editorView;
  this._widgetFactory = editorView.model.widgetFactory;
  this._viewFactory = editorView.model.viewFactory;
  this._widgetStore = editorView.model.widgetStore;
  this._editBufferMediator = editorView.model.editBufferMediator;
  this._contextResolver = editorView.model.contextResolver;
};

_.extend(module.exports.prototype, Backbone.Events, {

  /**
   * Requests that a new widget be inserted.
   *
   * @param {jQuery} $targetEl
   *   The element that the new widget will be inserted into.
   * @param {string} type
   *   The type of the item to request. This parameter is optional.
   *
   * @return {void}
   */
  create: function($targetEl, type) {
    this._editBufferMediator.requestBufferItem(type, $targetEl);
  },

  /**
   * Makes widget manager aware of a newly inserted widget.
   *
   * This is the most important method here. It is called when a new widget is
   * created in the editor in order to instruct the manager to start tracking
   * the lifecycle of the widget, its dom representation, and the edit buffer
   * data item it references.
   *
   * @param {mixed} widget
   *   The editor representation of a widget. This can be any data you want to
   *   associate with the widget, but will usually be an object generated by the
   *   editor. This will be available to the editor adapter during widget
   *   operations.
   * @param {mixed} id
   *   A unique identifier for the widget. This will usually be generated by the
   *   editor.
   * @param {jQuery} $targetEl
   *   The root element of the widget within the editor.
   *
   * @return {WidgetModel}
   *   The bound model.
   */
  bind: function(widget, id, $targetEl) {
    // Create a model for representing the widget.
    var widgetModel = this._widgetFactory.create(widget, id, $targetEl);
    var targetContext = widgetModel.editBufferItemRef.targetContext;
    var sourceContext = widgetModel.editBufferItemRef.sourceContext;

    // Create a widget view to render the widget within Editor.
    var widgetEditorView = this._viewFactory.create(widgetModel, $targetEl, 'editor');

    // Add the widget to the widget to the table to keep track of it.
    this._widgetStore.add(widgetModel, widgetEditorView);

    // Attach event handling.
    this.trigger('bind', this, widgetModel, widgetEditorView);

    this.listenTo(widgetModel, 'change', function() {
      if (widgetModel.hasState(WidgetModel.State.DESTROYED_REFS)) {
        this.trigger('unbind', this, widgetModel, widgetEditorView);
        this.stopListening(widgetModel);
      }
      if (widgetModel.hasState(WidgetModel.State.DESTROYED_WIDGET)) {
        this.trigger('destroy', this, widgetModel, widgetEditorView);
      }
    }, this);

    this.listenTo(widgetModel, 'save', function() {
      this.trigger('save', this, widgetModel, widgetEditorView);
    }, this);

    // If the widget is not currently using the editor view mode, we treat
    // it as being in 'export' form. This means we have to create an export
    // view to load the data.
    if (!widgetEditorView.isEditorViewRendered()) {
      this._viewFactory.createTemporary(widgetModel, $targetEl, 'export').save();
    }
    else {
      widgetEditorView.save();
    }

    // If there is more than one widget referencing the same buffer item we
    // need to duplicate it. Only one widget can ever reference a given
    // buffer item. Additionally, if the source context is not the same as the
    // target context we need to duplicate. A context mismatch essentially
    // means something was copied from another field instance into this field
    // instance, so all the data about it is in the original field instance.
    var matchingContexts = sourceContext.get('id') === targetContext.get('id');
    if (this._widgetStore.count(widgetModel) > 1 || !matchingContexts) {
      widgetModel.duplicate();
    }
    else {
      widgetEditorView.render();
    }

    return widgetModel;
  },

  /**
   * Unbinds (stops trakcing) a widget without destroying the widget itself.
   *
   * @param {mixed} id
   *   The id of the widget to be unbound.
   *
   * @return {WidgetModel}
   *   The saved model or undefined if no such model was found.
   */
  unbind: function(id) {
    return this._applyToModel(id, function(widgetModel) {
      this._widgetStore.remove(widgetModel, true);
    });
  },

  /**
   * Gets an existing widget.
   *
   * @param {mixed} id
   *   The widget id to lookup.
   *
   * @return {WidgetModel}
   *   A widget model if the id existed in the store, or undefined otherwise.
   */
  get: function(id) {
    return this._widgetStore.get(id, true).model;
  },

  /**
   * Requests an edit operation for a widget's referenced edit buffer item.
   *
   * This triggers an 'edit' command for the referenced edit buffer item. It's
   * up to the sync protcol plugin, and associated logic to determine how to
   * handle this command.
   *
   * @param {mixed} id
   *   The id of the model to generate an edit request for.
   *
   * @return {WidgetModel}
   *   The saved model or undefined if no such model was found.
   */
  edit: function(id) {
    return this._applyToModel(id, function(widgetModel) {
      widgetModel.edit();
    });
  },

  /**
   * Saves any inline edits to the widget.
   *
   * Note that this does not trigger a server sync. It simply updates the widget
   * model based on the current state of the editor view.
   *
   * The editor is in charge of managing the generated markup and sending it to
   * the server.
   *
   * @param {mixed} id
   *   The id of the widget to save inline edits for.
   * @param {jQuery} $targetEl
   *   The element to save the outputed data format to.
   *
   * @return {WidgetModel}
   *   The saved model or undefined if no such model was found.
   */
  save: function(id, $targetEl) {
    return this._applyToModel(id, function(widgetModel) {
      widgetModel.trigger('save');
      this._viewFactory.createTemporary(widgetModel, $targetEl, 'editor').save();
      this._viewFactory.createTemporary(widgetModel, $targetEl, 'export').render().save();
    });
  },

  /**
   * Destroys a widgets tracking data and initiates widget destruction.
   *
   * @param {mixed} id
   *   The id of the widget to be destroyed.
   * @param {bool} widgetDestroyed
   *   Set to true if the widget has already been destroyed in the editor.
   *   Setting this to false will result in the destruction of the widget within
   *   the editor.
   *
   * @return {WidgetModel}
   *   The destroyed model.
   */
  destroy: function(id, widgetDestroyed) {
    this._applyToModel(id, function(widgetModel) {
      if (widgetDestroyed) {
        widgetModel.setState(WidgetModel.State.DESTROYED_WIDGET);
      }
      widgetModel.destroy();
    });
  },

  /**
   * Cleans up after the widget manager object.
   *
   * @return {void}
   */
  close: function() {
    this._editorView.model.destroy();
    this._editorView.stopListening();
    this._widgetStore.cleanup();
    this._editBufferMediator.cleanup();
  },

  /**
   * Gets the settings for this binder instance.
   *
   * The settings are linked to the root (editor) context.
   *
   * @return {object}
   *   The settings object for the root context.
   */
  getSettings: function() {
    return this._contextResolver.getEditorContext().get('settings');
  },

  /**
   * Sets the settings for this binder instance.
   *
   * The settings are linked to the root (editor) context.
   *
   * @param {object} settings
   *   The settings object to write. Note that this will overwrite the *entire*
   *   existing settings object.
   *
   * @return {void}
   */
  setSettings: function(settings) {
    this._contextResolver.getEditorContext().set({ settings: settings });
  },

  /**
   * Gets an individual setting by name.
   *
   * The settings are linked to the root (editor) context.
   *
   * @param {string} name
   *   The name of the setting to lookup.
   *
   * @return {mixed}
   *   The setting value or undefined if no value was found.
   */
  getSetting: function(name) {
    return this._contextResolver.getEditorContext().getSetting(name);
  },

  /**
   * Resolves the context for an element.
   *
   * @param {jQuery} $el
   *   The element to resolve the context of.
   * @param {string} type
   *   The type of resolution to perform. The options are:
   *    - 'target': Resolves the conext at the elements position in the editor.
   *      This is usually the context you are looking for, and is the default
   *      if no type is explicitly provided.
   *    - 'source': Resolves the context the element has been tagged with.
   *      The source context may be different than the target context if, for
   *      example, the widget was recently copied from one context and pasted
   *      into another. The widget binder automatically resolves these
   *      situations in the background, so there should rarely be a situation
   *      where client code needs the source context.
   *
   * @return {Backbone.Model}
   *   The context model associated with the element.
   */
  resolveContext: function($el, type) {
    if (!type) {
      type = 'target';
    }
    if (type == 'target') {
      return this._contextResolver.resolveTargetContext($el);
    }
    else if (type == 'source') {
      return this._contextResolver.resolveSourceContext($el);
    }
    else {
      throw new Error('Invalid context type.');
    }
  },

  /**
   * A convenience function for looking up a widget and applying an action.
   *
   * @param {mixed} id
   *   The id of the widget to act on.
   * @param {function} callback
   *   The action to apply the model, if found.
   *
   * @return {WidgetModel}
   *   The model acted on, if an action was applied.
   */
  _applyToModel: function(id, callback) {
    var widgetModel = this.get(id);
    if (widgetModel) {
      callback.apply(this, [widgetModel]);
      return widgetModel;
    }
  }
});
